---
title: Typewriting Class
description: CSS-in-TS. Composable. Compiled. Correct.
template: splash
hero:
  tagline: CSS utilities as TypeScript functions. One import. Zero runtime.
  actions:
    - text: Get Started
      link: /getting-started/installation/
      icon: right-arrow
      variant: primary
    - text: View on GitHub
      link: https://github.com/corysimmons/typewritingclass
      icon: external
      variant: minimal
---

import { Card, CardGrid } from '@astrojs/starlight/components'

## Why Typewriting Class?

<CardGrid>
  <Card
    title="One import"
    icon="puzzle"
  >
    `import { tw } from 'typewritingclass'` -- chain utilities, modifiers, and
    shorthands off a single object. Full autocomplete, zero config.
  </Card>
  <Card
    title="TypeScript-native"
    icon="seti:typescript"
  >
    Utilities are functions, not string conventions. Full autocomplete, type
    checking, and refactoring support out of the box.
  </Card>
  <Card
    title="Zero runtime"
    icon="rocket"
  >
    The compiler extracts all static styles at build time. No runtime CSS
    generation, no style injection, no FOUC. Just plain CSS files.
  </Card>
  <Card
    title="Dynamic when needed"
    icon="random"
  >
    Wrap runtime values with `dynamic()` and use `dcx()` -- the compiler emits
    CSS custom properties and a tiny runtime handles the rest.
  </Card>
</CardGrid>

## Quick taste

```ts
import { tw } from 'typewritingclass'

const card = tw.p(4).bg.blue500.rounded.lg.hover.bg.blue600.md.p(8)
```

The compiler extracts this into static CSS at build time:

```css
@layer l0 { ._a1b2c { padding: 1rem; } }
@layer l1 { ._d3e4f { background-color: #3b82f6; } }
@layer l2 { ._g5h6i { border-radius: 0.5rem; } }
@layer l3 { ._j7k8l:hover { background-color: #2563eb; } }
@layer l4 { @media (min-width: 768px) { ._m9n0o { padding: 2rem; } } }
```

## The plugin model

Every utility and modifier follows the same two type signatures. Custom plugins slot in identically to built-ins -- no registration, no configuration, just import and use.

```ts
// A utility: takes a value, returns a StyleRule
type Utility = (value: any) => StyleRule

// A modifier: takes a StyleRule, returns a StyleRule
type Modifier = (rule: StyleRule) => StyleRule
```
