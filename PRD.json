{
  "project": {
    "name": "typewritingclass",
    "tagline": "CSS-in-TS. Composable. Compiled. Correct.",
    "description": "A CSS-in-TS framework where utilities are composable TypeScript functions, plugins are just functions, output is static CSS by default with dynamic escape hatches, and class order is respected via CSS @layer ordering.",
    "author": "Cory Simmons",
    "license": "MIT",
    "repository": "github.com/corysimmons/typewritingclass"
  },

  "philosophy": [
    "CSS utilities are TypeScript functions, not string conventions",
    "Two functions to learn: cx() to compose, when() to modify",
    "Plugins are just functions — same two type signatures as everything else",
    "Static by default — compiler extracts everything it can at build time",
    "Dynamic when needed — CSS custom properties as the escape hatch",
    "Class order matters — later utilities override earlier ones via @layer",
    "Type safety catches impossible CSS combinations at compile time",
    "Zero runtime by default, minimal runtime when dynamic values are used",
    "All design tokens are TypeScript variables — no magic strings"
  ],

  "monorepo": {
    "tool": "pnpm workspaces",
    "structure": {
      "packages": {
        "typewritingclass": "Core utility functions, cx(), when(), types, and default theme tokens",
        "typewritingclass-compiler": "Vite/esbuild/Babel plugin for static CSS extraction",
        "typewritingclass-runtime": "Dynamic value runtime via CSS custom properties (tree-shakeable)",
        "typewritingclass-theme": "Default theme (Tailwind-compatible tokens) and createTheme()",
        "typewritingclass-devtools": "VS Code extension and browser devtools integration"
      },
      "apps": {
        "docs": "Astro Starlight documentation site",
        "demo-react": "React demo app showcasing all features with interactive examples",
        "demo-vanilla": "Vanilla HTML/TS demo — no framework, just the core API",
        "demo-solid": "Solid.js demo app",
        "visual-tests": "Playwright visual regression test suite"
      }
    },
    "config": {
      "pnpm-workspace.yaml": "packages:\n  - 'packages/*'\n  - 'apps/*'",
      "notes": [
        "All packages use TypeScript with shared tsconfig base",
        "Shared ESLint and Prettier config at root",
        "Changesets for versioning and publishing",
        "Turborepo or pnpm run --filter for task orchestration"
      ]
    }
  },

  "documentation": {
    "framework": "Astro Starlight",
    "location": "apps/docs",
    "sections": [
      {
        "name": "Getting Started",
        "pages": [
          "Installation",
          "Quick Start",
          "Editor Setup",
          "Migrating from Tailwind"
        ]
      },
      {
        "name": "Core Concepts",
        "pages": [
          "Utility Functions",
          "Composing with cx()",
          "Modifiers with when()",
          "Responsive Design",
          "Dark Mode",
          "Layer Ordering",
          "Strict Mode"
        ]
      },
      {
        "name": "Theming",
        "pages": [
          "Default Theme Tokens",
          "Custom Themes with createTheme()",
          "Token Reference (colors, spacing, typography)"
        ]
      },
      {
        "name": "Plugins",
        "pages": [
          "Plugin Concepts — just two function signatures",
          "Writing Utility Plugins (value → StyleRule)",
          "Writing Modifier Plugins (StyleRule → StyleRule)",
          "Writing Composite Plugins (combining cx and when)",
          "Writing Recipe Plugins (variant-based component factories)",
          "Publishing and Sharing Plugins",
          "Plugin Examples Gallery"
        ]
      },
      {
        "name": "Advanced",
        "pages": [
          "Dynamic Values",
          "Raw CSS Escape Hatch",
          "Server Components (RSC)",
          "Performance"
        ]
      },
      {
        "name": "API Reference",
        "pages": [
          "Auto-generated from TSDoc — every utility, modifier, and helper fully documented"
        ]
      }
    ],
    "features": [
      "Live interactive code examples using embedded demo components",
      "Side-by-side comparisons: typewritingclass vs Tailwind vs Panda CSS vs vanilla CSS",
      "Visual output preview for every utility function",
      "Copy-paste ready examples for every feature",
      "Dedicated plugin authoring guide with cookbook-style examples"
    ]
  },

  "visual_regression_testing": {
    "description": "Screenshot-based visual regression tests comparing typewritingclass output against equivalent standard CSS for every feature. Ensures pixel-perfect correctness.",
    "tool": "Playwright with built-in screenshot comparison",
    "location": "apps/visual-tests",
    "strategy": [
      "For each utility/feature, create two pages: one using typewritingclass, one using equivalent hand-written CSS",
      "Screenshot both at multiple viewport sizes (mobile, tablet, desktop)",
      "Diff the screenshots — they must be pixel-identical",
      "Run on CI for every PR",
      "Store baseline screenshots in the repo",
      "Threshold: 0 pixel difference by default (configurable per-test for anti-aliasing edge cases)"
    ],
    "test_matrix": [
      {
        "category": "Spacing",
        "tests": [
          "p(), px(), py(), pt(), m(), mx(), gap() — all scale values and raw values"
        ]
      },
      {
        "category": "Colors",
        "tests": [
          "bg(), text color, border color — all theme colors and raw values"
        ]
      },
      {
        "category": "Typography",
        "tests": ["text sizes, font weights, line heights, letter spacing"]
      },
      {
        "category": "Layout",
        "tests": ["flex(), grid(), w(), h(), size() — all layout utilities"]
      },
      {
        "category": "Borders & Effects",
        "tests": ["rounded(), shadow(), ring(), border(), opacity()"]
      },
      {
        "category": "State Modifiers",
        "tests": [
          "when(hover), when(focus), when(active), when(disabled) — simulated via Playwright actions"
        ]
      },
      {
        "category": "Responsive",
        "tests": [
          "when(sm), when(md), when(lg), when(xl) — screenshot at each breakpoint"
        ]
      },
      {
        "category": "Composition & Ordering",
        "tests": [
          "cx() override behavior, when() modifier groups, multi-modifier stacking, layer ordering correctness"
        ]
      },
      {
        "category": "Dark Mode",
        "tests": ["when(dark) — screenshot with prefers-color-scheme toggled"]
      },
      {
        "category": "Dynamic Values",
        "tests": [
          "Runtime CSS custom property injection matches expected output"
        ]
      }
    ],
    "ci": {
      "runs_on": "Every PR and push to main",
      "browsers": ["Chromium (primary)", "Firefox", "WebKit"],
      "update_baselines": "pnpm --filter visual-tests update-snapshots"
    }
  },

  "architecture": {
    "overview": "Three-layer system: authoring API (TS functions) → compiler plugin (static extraction) → runtime (dynamic fallback)",

    "core_type_contract": {
      "description": "The entire system reduces to two function signatures. Every utility, modifier, plugin, and built-in is one of these two shapes.",
      "types": {
        "Utility": "(value: TokenOrRaw) => StyleRule — takes a value, returns a style rule",
        "Modifier": "(rule: StyleRule) => StyleRule — takes a style rule, returns a wrapped style rule"
      },
      "public_api": {
        "cx": "(...rules: StyleRule[]) => string — composes utilities into a class string, order determines override priority",
        "when": "(...modifiers: Modifier[]) => (...rules: StyleRule[]) => StyleRule — applies a modifier stack to a group of utilities"
      },
      "implication": "Users learn two functions (cx, when). Plugin authors learn two type signatures (Utility, Modifier). Everything composes with everything automatically."
    },

    "layers": {
      "authoring_api": {
        "description": "TypeScript functions that represent CSS utilities. Each function returns a StyleRule object containing the CSS properties, a deterministic hash for class naming, and metadata for layer ordering.",
        "requirements": [
          "Every utility is a pure function returning a StyleRule",
          "cx() composes utilities — order determines override priority via @layer",
          "when() applies modifiers — accepts any number of Modifier functions, returns a function that accepts any number of StyleRules",
          "All design tokens (colors, spacing, etc.) are TS variables with autocomplete, not magic strings",
          "Supports parameterized utilities with theme scale or raw values: size(4) or size('1rem')",
          "Modifiers (hover, focus, dark, md, etc.) are Modifier-typed functions consumed exclusively through when()",
          "Users never call modifier functions directly — when() is the only public interface for applying modifiers"
        ]
      },

      "compiler": {
        "description": "A Vite/esbuild/Babel plugin that statically analyzes and extracts CSS at build time. Evaluates pure function trees, emits atomic CSS rules ordered by @layer, and replaces call sites with class name strings.",
        "requirements": [
          "Static extraction of all deterministic style function calls",
          "Emits CSS rules wrapped in @layer declarations to enforce ordering",
          "Replaces style function calls with generated class name strings in JS output",
          "Tree-shakes unused utilities",
          "Source maps from generated class names back to TS call sites",
          "Detects dynamic values and falls back to runtime mode for those calls",
          "Deduplicates identical CSS rules across the entire bundle",
          "Supports Vite, esbuild, and Babel as host bundlers",
          "Strict mode (default on): errors on dynamic values unless explicitly opted in via dynamic() wrapper"
        ]
      },

      "runtime": {
        "description": "A minimal runtime (~1KB) that handles dynamic style values via CSS custom properties. Only included in the bundle when dynamic styles are detected.",
        "requirements": [
          "Injects CSS custom properties for dynamic values",
          "Static CSS structure is still extracted at build — only values are dynamic",
          "Runtime is tree-shaken entirely if no dynamic styles are used",
          "Provides a useStyle() hook for React (and framework-agnostic equivalent)",
          "Batches DOM updates for multiple dynamic property changes"
        ]
      }
    }
  },

  "api_design": {
    "syntax_decision": {
      "approach": "Two public functions: cx() for composition, when() for modifiers. That's the entire API surface.",
      "rationale": [
        "One way to compose (cx), one way to modify (when) — zero 'which syntax?' decisions",
        "when() reads left-to-right: when(dark, hover)(bg(blue[600]), text(white))",
        "Partially applied when() is reusable: const darkHover = when(dark, hover)",
        "Modifier functions (hover, dark, md) exist as building blocks but are consumed exclusively through when()",
        "Plugin authors write Utility or Modifier functions — when() picks them up automatically"
      ]
    },

    "token_system": {
      "description": "All design tokens are TypeScript variables imported from the theme. No magic strings anywhere.",
      "examples": [
        {
          "import": "import { blue, red, gray, white } from 'typewritingclass/theme/colors'",
          "usage": "bg(blue[500])"
        },
        {
          "import": "import { lg, md as textMd } from 'typewritingclass/theme/typography'",
          "usage": "text(lg)"
        },
        {
          "import": "import { full, screen } from 'typewritingclass/theme/sizes'",
          "usage": "w(full)"
        }
      ],
      "raw_values": "Always supported alongside tokens: bg('#ff00ff'), p('13px'), w('calc(100% - 2rem)')"
    },

    "core_utilities": {
      "description": "Atomic CSS property functions. Accept theme tokens (number for scale, TS variable for named tokens) or raw string values.",
      "examples": [
        { "call": "p(4)", "output": "padding: 1rem (theme scale)" },
        { "call": "p('13px')", "output": "padding: 13px (raw value)" },
        {
          "call": "px(2)",
          "output": "padding-left: 0.5rem; padding-right: 0.5rem"
        },
        {
          "call": "bg(blue[500])",
          "output": "background-color: #3b82f6 (theme token)"
        },
        {
          "call": "bg('#ff00ff')",
          "output": "background-color: #ff00ff (raw value)"
        },
        { "call": "size(2)", "output": "width: 0.5rem; height: 0.5rem" },
        { "call": "flex()", "output": "display: flex" },
        {
          "call": "grid(3)",
          "output": "display: grid; grid-template-columns: repeat(3, 1fr)"
        },
        {
          "call": "text(lg)",
          "output": "font-size: 1.125rem; line-height: 1.75rem (theme token)"
        },
        {
          "call": "rounded(md)",
          "output": "border-radius: 0.375rem (theme token)"
        },
        { "call": "w(full)", "output": "width: 100% (theme token)" },
        { "call": "gap(4)", "output": "gap: 1rem" }
      ]
    },

    "composition_cx": {
      "description": "cx() composes multiple utilities and when() results into a single class string. Order determines override priority via @layer.",
      "examples": [
        {
          "call": "cx(flex(), gap(4), p(2), bg(white))",
          "output": "Class string with 4 atomic classes, layered so bg(white) wins on conflict"
        },
        {
          "call": "cx(p(4), p(2))",
          "output": "Only p(2) applies — later overrides earlier via @layer ordering"
        },
        {
          "description": "Full component example",
          "call": "cx(\n  bg(white),\n  p(6),\n  rounded(lg),\n  shadow(md),\n  when(hover)(bg(blue[50]), shadow(lg)),\n  when(dark)(bg(gray[800]), text(white)),\n  when(dark, hover)(bg(gray[700])),\n  when(md)(p(8), grid(3)),\n)"
        }
      ]
    },

    "when_modifier": {
      "description": "when() is the only way to apply modifiers. Takes any number of Modifier functions, returns a function that takes any number of StyleRules. Reads left-to-right. Partially applicable for reuse.",
      "signature": "when(...modifiers: Modifier[]) => (...rules: StyleRule[]) => StyleRule",
      "implementation_note": "Internally does modifiers.reduceRight((acc, mod) => mod(acc), cx(...rules))",
      "examples": [
        {
          "description": "Single modifier, single utility",
          "call": "when(hover)(bg(blue[600]))",
          "output": "&:hover { background-color: #2563eb }"
        },
        {
          "description": "Single modifier, multiple utilities",
          "call": "when(hover)(bg(blue[600]), shadow(lg))",
          "output": "&:hover { background-color: ...; box-shadow: ... }"
        },
        {
          "description": "Multiple modifiers stacked",
          "call": "when(dark, hover)(bg(blue[600]), text(white), border(blue[400]))",
          "output": "@media (prefers-color-scheme: dark) { &:hover { ... } }"
        },
        {
          "description": "Responsive modifier",
          "call": "when(md)(grid(3), gap(6), p(8))",
          "output": "@media (min-width: 768px) { display: grid; ... }"
        },
        {
          "description": "Reusable modifier stack via partial application",
          "call": "const darkHover = when(dark, hover)\n\ncx(\n  bg(blue[500]),\n  darkHover(bg(blue[700]), text(white)),\n)",
          "note": "Store it, name it, export it, pass it around — it's just a function"
        },
        {
          "description": "Disabled state overriding hover",
          "call": "cx(\n  bg(blue[500]),\n  when(hover)(bg(blue[600])),\n  when(disabled)(bg(gray[300]), cursor('not-allowed')),\n  when(disabled, hover)(bg(gray[300])),\n)",
          "note": "Last when() wins on conflict via @layer ordering"
        },
        {
          "description": "Complex responsive + state + dark mode",
          "call": "cx(\n  grid(1),\n  when(sm)(grid(2)),\n  when(md)(grid(3)),\n  when(lg)(grid(4)),\n  when(hover)(shadow(lg)),\n  when(dark)(bg(gray[900])),\n  when(dark, hover)(bg(gray[800]),  shadow(xl)),\n)"
        }
      ]
    },

    "dynamic_values": {
      "description": "When a value can't be known at build time, wrap in dynamic() to opt out of strict mode. Compiler emits a CSS custom property and the runtime sets it.",
      "examples": [
        {
          "call": "bg(dynamic(props.color))",
          "behavior": "Compiles to static rule with var(--bg-dynamic-x), runtime sets --bg-dynamic-x"
        },
        {
          "call": "w(dynamic(`${progress}%`))",
          "behavior": "Static structure extracted, dynamic percentage via custom property"
        }
      ]
    },

    "plugins": {
      "description": "Plugins are just functions matching one of two signatures: Utility (value → StyleRule) or Modifier (StyleRule → StyleRule). No registration, no config, no special API. Import and use. They compose with cx() and when() automatically because they're the same types.",
      "utility_plugins": {
        "description": "A function that returns a StyleRule. Slots into cx() like any built-in utility.",
        "examples": [
          {
            "name": "glass",
            "description": "Glass morphism effect",
            "code": "import { cx, bg, backdrop } from 'typewritingclass'\n\nexport const glass = (blur = 10) =>\n  cx(bg('rgba(255,255,255,0.1)'), backdrop(`blur(${blur}px)`))",
            "usage": "cx(glass(), p(4), rounded(lg))"
          },
          {
            "name": "card",
            "description": "Card component with overridable defaults",
            "code": "import { cx, rounded, shadow, p, bg, white } from 'typewritingclass'\nimport { lg, md } from 'typewritingclass/theme/sizes'\n\nexport const card = (...styles: StyleRule[]) =>\n  cx(rounded(lg), shadow(md), p(6), bg(white), ...styles)",
            "usage": "card(bg(blue[50]))\ncx(card(), m(4))"
          },
          {
            "name": "truncate",
            "description": "Text truncation with ellipsis",
            "code": "import { css } from 'typewritingclass'\n\nexport const truncate = () =>\n  css({ overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' })",
            "usage": "cx(truncate(), w(48), text(sm))"
          }
        ]
      },
      "modifier_plugins": {
        "description": "A function that takes a StyleRule and returns a StyleRule. Slots into when() like any built-in modifier (hover, dark, md, etc.).",
        "examples": [
          {
            "name": "animate",
            "description": "Adds transition to any style rule",
            "code": "import { cx, css } from 'typewritingclass'\nimport type { StyleRule } from 'typewritingclass'\n\nexport const animate = (rule: StyleRule): StyleRule =>\n  cx(rule, css({ transition: 'all 150ms ease' }))",
            "usage": "when(animate)(bg(blue[500]))\nwhen(hover, animate)(bg(blue[600]), shadow(lg))\nwhen(dark, hover, animate)(bg(blue[700]), text(white))"
          },
          {
            "name": "groupHover",
            "description": "Style children when parent group is hovered",
            "code": "import type { StyleRule } from 'typewritingclass'\n\nexport const groupHover = (rule: StyleRule): StyleRule =>\n  wrapSelector(rule, '.group:hover &')",
            "usage": "when(groupHover)(opacity(100), translate('y', -1))"
          },
          {
            "name": "print",
            "description": "Print media query modifier",
            "code": "import type { StyleRule } from 'typewritingclass'\n\nexport const print = (rule: StyleRule): StyleRule =>\n  wrapMedia(rule, 'print')",
            "usage": "when(print)(bg(white), text(black), shadow('none'))"
          }
        ]
      },
      "composite_plugins": {
        "description": "Plugins that combine cx() and when() to create reusable component patterns. These are just regular functions — no special plugin API.",
        "examples": [
          {
            "name": "button",
            "description": "A full button component with variants",
            "code": "import { cx, when, bg, text, px, py, rounded, shadow, cursor } from 'typewritingclass'\nimport { blue, gray, white, red } from 'typewritingclass/theme/colors'\nimport { md } from 'typewritingclass/theme/sizes'\n\nconst baseButton = cx(\n  px(4), py(2), rounded(md),\n  font('semibold'), cursor('pointer'),\n  when(disabled)(opacity(50), cursor('not-allowed')),\n)\n\nexport const button = {\n  primary: cx(\n    baseButton,\n    bg(blue[500]), text(white),\n    when(hover)(bg(blue[600])),\n    when(active)(bg(blue[700])),\n  ),\n  danger: cx(\n    baseButton,\n    bg(red[500]), text(white),\n    when(hover)(bg(red[600])),\n    when(active)(bg(red[700])),\n  ),\n  ghost: cx(\n    baseButton,\n    bg('transparent'), text(gray[700]),\n    when(hover)(bg(gray[100])),\n  ),\n}",
            "usage": "<button className={button.primary}>Save</button>"
          },
          {
            "name": "recipe (CVA-style variant factory)",
            "description": "Generic variant-based component factory — itself a plugin built on cx() and when()",
            "code": "export const recipe = <V extends Record<string, Record<string, string>>>(config: {\n  base: string,\n  variants: V,\n}) => (selected: Partial<{ [K in keyof V]: keyof V[K] }>) => {\n  const variantClasses = Object.entries(selected)\n    .map(([key, value]) => config.variants[key]?.[value as string])\n    .filter(Boolean)\n  return cx(config.base, ...variantClasses)\n}",
            "usage": "const chip = recipe({\n  base: cx(px(3), py(1), rounded(full), text(sm)),\n  variants: {\n    color: {\n      blue: cx(bg(blue[100]), text(blue[800])),\n      red: cx(bg(red[100]), text(red[800])),\n    },\n    size: {\n      sm: cx(px(2), text(xs)),\n      lg: cx(px(4), py(2), text(base)),\n    }\n  }\n})\n\nchip({ color: 'blue', size: 'lg' })"
          }
        ]
      },
      "plugin_authoring_rules": [
        "A plugin is just a function — no registration, no config objects, no lifecycle hooks",
        "Return a StyleRule to make a utility plugin",
        "Accept a StyleRule and return a StyleRule to make a modifier plugin",
        "Combine cx() and when() to make composite plugins",
        "Plugins get full TypeScript type inference automatically",
        "Plugins are statically extractable if they only use pure functions and constant values",
        "Plugins compose with all built-in utilities, modifiers, and other plugins — no special wiring",
        "Publish as a regular npm package — users just import and use"
      ]
    },

    "raw_escape_hatch": {
      "description": "For CSS not covered by utilities",
      "examples": [
        {
          "call": "css({ clipPath: 'polygon(50% 0%, 0% 100%, 100% 100%)' })",
          "output": "Arbitrary CSS object compiled to a class"
        },
        {
          "call": "css`clip-path: polygon(50% 0%, 0% 100%, 100% 100%)`",
          "output": "Tagged template literal alternative"
        }
      ]
    }
  },

  "layer_ordering": {
    "description": "CSS @layer is used to make class order in markup determine override priority. The compiler assigns layers based on composition order at per-utility granularity.",
    "strategy": [
      "Define a @layer stack at the top of the generated stylesheet",
      "Base utilities go in the lowest layer",
      "Each utility within a cx() call gets its own layer index — maximum granularity",
      "Later items in cx() get higher-priority layers",
      "when() output is layered at the position it appears within its parent cx()",
      "Stacked modifiers in when(dark, hover) get nested layers preserving the modifier order",
      "User-defined layers via layer() function for explicit control"
    ],
    "example_output": [
      "@layer base, utilities, states, responsive, overrides;",
      "@layer utilities { .px-2 { padding-left: 0.5rem; padding-right: 0.5rem } }",
      "@layer overrides { .p-4 { padding: 1rem } }"
    ]
  },

  "type_system": {
    "description": "TypeScript types that prevent invalid CSS at compile time",
    "features": [
      "Two core types: Utility (value → StyleRule) and Modifier (StyleRule → StyleRule)",
      "Branded types for CSS units — can't pass a color where a size is expected",
      "Theme tokens are typed objects — blue[500] autocompletes, blue[999] is a compile error",
      "Return type of every utility encodes what CSS properties it sets",
      "cx() type checks for conflicting properties and warns (optional strict mode)",
      "when() is fully typed — first call takes Modifiers, second call takes StyleRules",
      "Plugin authors get full type inference — no manual type annotations needed",
      "Custom modifier plugins are type-checked when passed to when()"
    ]
  },

  "theme_system": {
    "description": "Themes are TypeScript objects. Token values flow through the type system. All tokens are importable variables with full autocomplete.",
    "features": [
      "Default theme ships with Tailwind-compatible tokens (colors, spacing, typography, shadows, etc.)",
      "Colors: import { blue, red, gray, ... } from 'typewritingclass/theme/colors'",
      "Spacing: numeric scale (1-96) maps to rem values, always allows raw string override",
      "Typography: import { sm, base, lg, xl, ... } from 'typewritingclass/theme/typography'",
      "createTheme() generates typed token objects from custom values",
      "Tokens compile to CSS custom properties for runtime theme switching",
      "Theme merging/extending via spread operator",
      "Multiple themes supported via CSS custom property scoping on data attributes"
    ]
  },

  "developer_experience": {
    "requirements": [
      "Full autocomplete for all tokens and utilities in any TS-aware editor",
      "Hover documentation showing computed CSS for any utility call",
      "Compile-time errors for invalid CSS values, wrong token types, or impossible combinations",
      "Source maps from browser devtools back to TS call sites",
      "Optional VS Code extension for inline CSS preview",
      "Fast compilation — target <100ms incremental builds",
      "Hot module replacement preserves styles without full page reload"
    ]
  },

  "implementation_plan": {
    "phase_1": {
      "name": "Core API + Static Extraction",
      "tasks": [
        "Set up pnpm workspace monorepo with packages/ and apps/ directories",
        "Define StyleRule type and Utility/Modifier type contract",
        "Implement cx() composition function with @layer ordering",
        "Implement when() modifier application with reduceRight composition",
        "Implement default theme token objects (colors, spacing, typography, sizes)",
        "Implement base utility functions (spacing, color, typography, layout, borders, effects)",
        "Implement built-in modifier functions (hover, focus, active, disabled, focusVisible, dark, sm, md, lg, xl, 2xl)",
        "Build deterministic class name hashing",
        "Build @layer ordering system with per-utility granularity",
        "Write Vite plugin for static extraction — evaluate pure fn calls at build time",
        "Replace call sites with class name strings in JS output",
        "Emit deduplicated, layer-ordered CSS file",
        "Set up visual regression test infrastructure with Playwright",
        "Write visual regression tests for every utility as they are implemented",
        "Set up demo-vanilla app as the first demo"
      ]
    },

    "phase_2": {
      "name": "Dynamic Runtime + Theme System",
      "tasks": [
        "Implement dynamic() wrapper and strict mode (default on) in compiler",
        "Build minimal runtime for CSS custom property injection",
        "Implement useStyle() React hook",
        "Build framework-agnostic runtime API",
        "Implement createTheme() and theme customization",
        "Implement theme switching via custom property scoping",
        "Implement css() escape hatch (object and tagged template)",
        "Tree-shake runtime when no dynamic styles detected",
        "Set up demo-react app with interactive examples",
        "Visual regression tests for dynamic values and theme switching"
      ]
    },

    "phase_3": {
      "name": "DX Polish + Ecosystem",
      "tasks": [
        "Comprehensive JSDoc documentation with rich examples on every exported type, function, and interface — hover-friendly descriptions showing CSS output, usage patterns, and edge cases",
        "Branded/nominal types for CSS units — prevent passing a color where a size is expected, catch impossible combinations at compile time",
        "cx() conflict detection — warn on conflicting properties in strict mode",
        "layer() function for explicit user-defined layer control",
        "Source map generation from class names to TS call sites",
        "VS Code extension for inline CSS preview on hover",
        "esbuild plugin (in addition to Vite)",
        "Babel plugin for non-Vite/esbuild users",
        "React Server Components compatibility — static extraction during server rendering",
        "Performance benchmarking against Tailwind, Vanilla Extract, Panda CSS",
        "Build Astro Starlight documentation site with live examples",
        "Plugin authoring guide with utility, modifier, and composite plugin cookbook examples",
        "Set up demo-solid app",
        "CI pipeline: visual regression tests on all PRs across Chromium, Firefox, WebKit",
        "Additional visual tests: state modifiers (hover, focus, disabled), dark mode, responsive breakpoints, multi-viewport",
        "Starter templates for React, Solid, Svelte, vanilla"
      ]
    }
  },

  "technical_decisions": {
    "language": "TypeScript (library + compiler plugin)",
    "package_manager": "pnpm with workspaces",
    "build_targets": [
      "Vite plugin (primary)",
      "esbuild plugin (secondary)",
      "Babel plugin (tertiary)"
    ],
    "css_output": "Atomic CSS with @layer ordering",
    "class_naming": "Deterministic hash-based (e.g., _sx7k2)",
    "default_theme_scale": "Tailwind-compatible spacing/color/typography tokens for easy migration",
    "testing": {
      "unit": "Vitest for unit tests",
      "integration": "Playwright for integration tests",
      "visual_regression": "Playwright screenshot diffing — every utility tested against equivalent hand-written CSS"
    },
    "documentation": "Astro Starlight",
    "monorepo": true,
    "packages": [
      {
        "name": "typewritingclass",
        "description": "Core: cx(), when(), utility functions, types"
      },
      {
        "name": "typewritingclass-compiler",
        "description": "Vite/esbuild/Babel plugin for static extraction"
      },
      {
        "name": "typewritingclass-runtime",
        "description": "Dynamic value runtime (tree-shakeable)"
      },
      {
        "name": "typewritingclass-theme",
        "description": "Default theme tokens and createTheme()"
      },
      {
        "name": "typewritingclass-devtools",
        "description": "VS Code extension and browser devtools"
      }
    ],
    "apps": [
      { "name": "docs", "description": "Astro Starlight documentation site" },
      {
        "name": "demo-react",
        "description": "React demo with interactive examples"
      },
      { "name": "demo-vanilla", "description": "Vanilla HTML/TS demo" },
      { "name": "demo-solid", "description": "Solid.js demo" },
      {
        "name": "visual-tests",
        "description": "Playwright visual regression test suite"
      }
    ]
  },

  "competitive_landscape": {
    "tailwind": "String-based, no type safety, class conflicts require arbitrary specificity hacks, magic string tokens",
    "vanilla_extract": "TS-based but verbose API, no composable utilities, no ordering guarantees",
    "panda_css": "Closest competitor — config-driven, uses codegen. typewritingclass is simpler: two functions (cx + when), no config, no magic strings",
    "styled_components": "Runtime-heavy, no static extraction, different mental model",
    "linaria": "Static extraction but limited composition, tagged templates only",
    "unocss": "Fast but still string-based utilities, same limitations as Tailwind"
  },

  "resolved_decisions": [
    {
      "question": "Should the default API use a spacing scale or raw values?",
      "answer": "Both. Ship a default theme with a spacing/sizing scale (size(4) = 1rem) but always allow raw values (size('1rem'), size('73px')). Same pattern as Tailwind's arbitrary values but native to the function API."
    },
    {
      "question": "How granular should @layer ordering be?",
      "answer": "As granular as possible — per-utility level. Each utility in a cx() call gets its own layer index so ordering is fully deterministic at the finest grain."
    },
    {
      "question": "Should there be a Babel plugin path for non-Vite/esbuild users?",
      "answer": "Yes. Babel plugin is a supported target alongside Vite and esbuild."
    },
    {
      "question": "RSC compatibility — can we extract during server rendering?",
      "answer": "Yes. RSC compatibility is a requirement. Static extraction should work during server rendering."
    },
    {
      "question": "Should the compiler support a strict mode that errors on dynamic values?",
      "answer": "Yes, and strict mode is the default. Users must explicitly opt into dynamic values via dynamic() wrapper. This encourages static-first patterns and makes the zero-runtime guarantee the default path."
    },
    {
      "question": "Should design tokens be strings or TS variables?",
      "answer": "TS variables. All tokens (colors, typography scales, size keywords) are importable TypeScript objects. blue[500] not 'blue-500'. Gives autocomplete, type safety, jump-to-definition, and refactoring support. Raw string values always accepted as an escape hatch."
    },
    {
      "question": "API syntax for modifiers and composition?",
      "answer": "Two public functions only: cx() for composing utilities, when() for applying modifiers. No bare HOF calls (users don't call hover() directly), no pipe(). Modifier functions exist internally as (StyleRule => StyleRule) building blocks consumed exclusively through when(). This gives one way to compose, one way to modify, zero syntax decisions."
    },
    {
      "question": "Can plugin authors still write custom modifiers and utilities easily?",
      "answer": "Yes. The type contract is unchanged: write a (value => StyleRule) for a utility plugin, or a (StyleRule => StyleRule) for a modifier plugin. Custom modifiers slot into when() identically to built-ins. Custom utilities slot into cx() identically to built-ins. No registration, no config — just export a function."
    }
  ]
}
